= Section 2 - Log Enrichment and Prompt Generation Workflow

== Objective

In this section, we will build the first workflow called the **AI Insights and Lightspeed prompt generationn** workflow. This workflow will be triggered by Event-Driven Ansible (EDA) whenever an issue is detected in the system. Specifically, this demo is set up to respond to an Apache (httpd) service failure.

This workflow will check the status of the Apache service, notify a Mattermost channel with details, ask Red Hat AI to analyze the incident, and finally create a new job template using the AI-generated prompt for Ansible Lightspeed.

image::enrichment_workflow_diagram.png[Enrichment and Prompt Generation Workflow]

By organizing these steps into a workflow, we simulate how multiple tools can collaborate to enrich a ticket or alert and prepare the remediation plan‚Äîall before a human even reviews the problem.

[quote]
‚ö†Ô∏è This workflow will be automatically triggered by EDA once the `‚ùå Break Apache` job template is run. You must create this workflow before simulating the failure.

== Introducing AI with Ansible

Red Hat AI is already deployed in this lab and powered by the **Granite LLM** model. You can interact with this AI using simple curl commands or trigger it through Job Templates via Ansible Automation Platform.

Red Hat AI is deployed using two Ansible Content Collections:

* `redhat.ai` (Certified)
* `infra.ai` (Validated)

These are available as part of your AAP subscription, giving your organization a quick and validated path to deploy generative AI models using automation.

=== Try It Yourself: Talk to the AI!

Before diving into the workflow, let‚Äôs see how easy it is to test this out yourself.

1. Open the **Terminal** in the lab.
2. Run the following `curl` command (replace `<TOKEN>` with your lab password):

[source,shell]
----
curl -X POST http://rhelai.example.com:8000/v1/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <TOKEN>" \
  -d '{
    "model": "/root/.cache/instructlab/models/granite-8b-lab-v1",
    "prompt": "What is the capital of USA?",
    "max_tokens": 100,
    "temperature": 0
  }' | jq -r '.choices[0].text'
----

You can also try real-world prompts like:

[source,shell]
----
curl -X POST http://rhelai.example.com:8000/v1/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <TOKEN>" \
  -d '{
    "model": "/root/.cache/instructlab/models/granite-8b-lab-v1",
    "prompt": "systemd[1]: httpd.service: Failed with result exit-code. Suggest a fix for Apache.",
    "max_tokens": 150,
    "temperature": 0.6
  }' | jq -r .choices[0].text
----

This returns a JSON response with helpful AI suggestions. This is exactly what‚Äôs being automated in the next step via the **ü§ñ RHEL AI: Analyze Incident** job template.

== Exploring Mattermost Integration

In this lab environment, we‚Äôve included Mattermost, a lightweight, open-source chat client that serves as a central place to view error logs and AI insights as part of your AI-Ops workflow.

Think of Mattermost as a stand-in for ServiceNow in this demonstration.

[quote]
üí° In a real-world production environment, you can easily replace Mattermost with ServiceNow (or any other ITSM tool). This enables a more advanced automated workflow, where tickets are automatically created and enriched with logs and insights ‚Äî all before a human even picks up the ticket!

=== Accessing Mattermost
	1.	Navigate to the Mattermost tab in the lab landing page (or use the direct link provided).
	2.	Click on ‚ÄúView in Browser‚Äù to open the console.
	3.	Login using the credentials provided in the Mattermost section of the lab‚Äôs landing page:

[options=‚Äúheader‚Äù]
|===
| Field | Value
| Username | ansibleadmin@ansible.com
| Password | ansible123!
|===

Once logged in, click on the Town Square channel from the left-hand navigation.

image::mattermost_town_square_placeholder.png[Click on Town Square, 60%, link=‚Äúreplace_with_actual_image_later‚Äù]

=== What You‚Äôll See in Town Square

In the Town Square channel, you will begin seeing:
	‚Ä¢	üîç Error logs from the Apache HTTPD service (collected by Filebeat and forwarded via Kafka)
	‚Ä¢	üß† AI Insights generated from the logs using RHEL AI

This real-time feed mimics how production environments might use automated ticket enrichment ‚Äî by capturing logs and insights and sending them directly to a ticketing system like ServiceNow.

[quote]
üí° With this integration, you are essentially watching AI and automation work together ‚Äî detecting the issue, diagnosing it, and preparing remediation guidance before anyone intervenes.


== Build the Workflow

Login to Ansible Automation Platform.

Go to Automation Execution ‚Üí Templates.

image::automation_execution_templates.png[automation_execution_templates]

Click Create template ‚Üí Create workflow job template.

image::create_workflow.png[create_workflow,300]

Fill in the details:

[options="header"]
|===
| Parameter | Value
| Name | AI Insights and Lightspeed prompt generation
| Organization | Default
|===

Click Create workflow job template.

image::create_workflow_job_template.png[create_workflow_job_template,300]

You‚Äôll see the empty workflow visualizer.

image::currently_no_nodes_workflow.png[currently_no_nodes_workflow,400]

Add the Apache Service Status Check node:

[options="header"]
|===
| Parameter | Value
| Node type | Job Template
| Job Template | ‚öôÔ∏è Apache Service Status Check
| Convergence | Any
| Node alias | (You can leave this blank)
|===

image::add_apache_status_check_step.png[Add Apache Status Check Step]

Click Next, then Finish.

image::blue_next_button.png[blue_next_button,150]
image::blue_finish_button.png[blue_finish_button,150]

Visual after first node:

image::workflow_after_apache_status_node.png[Workflow after Apache node]

Add RHEL AI: Analyze Incident step:

[options="header"]
|===
| Parameter | Value
| Node type | Job Template
| Job Template | ü§ñ RHEL AI: Analyze Incident
| Status | Run on success
| Convergence | Any
| Node alias | (You can leave this blank)
|===

image::add_rhel_ai_step.png[Add RHEL AI Step]

Click Next, then Finish.

image::blue_next_button.png[]
image::blue_finish_button.png[]

Workflow with two nodes:

image::workflow_after_rhel_ai_step.png[After RHEL AI step]

Add Notify via Mattermost:

[options="header"]
|===
| Parameter | Value
| Node type | Job Template
| Job Template | üì£ Notify via Mattermost
| Status | Run on success
| Convergence | Any
| Node alias | (You can leave this blank)
|===

image::add_mattermost_step.png[Add Mattermost Step]

Click Next, then Finish.

image::workflow_after_mattermost_step.png[After Mattermost step]

Add Build Ansible Lightspeed Job Template:

[options="header"]
|===
| Parameter | Value
| Node type | Job Template
| Job Template | ‚öôÔ∏è Build Ansible Lightspeed Job Template
| Status | Run on success
| Convergence | Any
| Node alias | (You can leave this blank)
|===

image::add_lightspeed_jt_creator.png[Add Lightspeed JT Creator Step]

Click Next, then Finish.

image::blue_next_button.png[]
image::blue_finish_button.png[]

Final workflow visual:

image::workflow_final_prompt_generation.png[Final Workflow]

Click Save to finalize.

image::save_button.png[]

== Trigger the Workflow

Run the `‚ùå Break Apache` job template. This inserts an invalid directive in Apache config and restarts the service.

image::run_break_apache.png[]

Go to EDA Controller ‚Üí Rulebook Activations. Confirm EDA picked up the event.

image::eda_trigger_capture.png[]

Go to Automation Controller ‚Üí Jobs. Confirm workflow execution.

image::workflow_triggered_jobs.png[]

Go to Templates and you should be able to see a new template called "üß† Lightspeed Remediation Playbook Generator" generated.

== Summary

You created a workflow that:

Uses logs for root cause analysis via Red Hat AI

Notifies Mattermost

Prepares a Lightspeed prompt for automated playbook generation

In the next step, we‚Äôll use that prompt to fix Apache automatically!

== Complete

You have completed this module. Move forward to the next one to use the created template.